#Design an environment consisting of a single producer class "producer" 
#three subscribers viz., iz. "SUB1", "SUB2", and "SUB3". 
#Add logic such that the producer broadcasts the name of the coder and all the subscribers are able to receive the string data sent by the producer. 
#If Zen is writing the logic, then the producer should broadcast the string "ZEN" and all the subscribers must receive "ZEN"


`include "uvm_macros.svh"
  import uvm_pkg::*;
  
   class producer extends uvm_component;
     `uvm_component_utils(producer)
      string str="ZEN";
     uvm_analysis_port #(string) send;
     function new(string name="PRODUCER",uvm_component parent =null);
      super.new(name,parent);
    endfunction
    
    function void build_phase(uvm_phase phase);
      super.build_phase(phase);
      send=new("send",this);
  endfunction
 
     task run_phase(uvm_phase phase);
      phase.raise_objection(this);
       send.write(str);
       `uvm_info("pro",$sformatf("sending :%s",str),UVM_NONE);
      phase.drop_objection(this);
    endtask
  endclass 
   
  
  ///////////////////////subsriber1///////////////////////
  
 class SUB1 extends uvm_component;
   `uvm_component_utils(SUB1)

   uvm_analysis_imp #(string,SUB1) imp1;
   function new(string name="SUB1",uvm_component parent =null);
      super.new(name,parent);
    endfunction
    
    function void build_phase(uvm_phase phase);
      super.build_phase(phase);
      imp1=new("imp1",this);
      
    endfunction
    
   function void write(string str) ;
     `uvm_info("sub1",$sformatf("receiving sub1 :%s",str),UVM_NONE);
   endfunction
  endclass 
   
     ///////////////////////subsriber2///////////////////////

  class SUB2 extends uvm_component;
    `uvm_component_utils(SUB2)

    uvm_analysis_imp #(string,SUB2) imp2;
    function new(string name="SUB2",uvm_component parent =null);
      super.new(name,parent);
    endfunction
    
    function void build_phase(uvm_phase phase);
      super.build_phase(phase);
      imp2=new("imp2",this);
      
    endfunction
    
    function void write(string str) ;
     `uvm_info("sub2",$sformatf("receiving sub2 :%s",str),UVM_NONE);
    endfunction
  endclass

  ///////////////////////subsriber3///////////////////////

  
  class SUB3 extends uvm_component;
    `uvm_component_utils(SUB3)

    uvm_analysis_imp #(string,SUB3) imp3;
    function new(string name="SUB3",uvm_component parent =null);
      super.new(name,parent);
    endfunction
    
    function void build_phase(uvm_phase phase);
      super.build_phase(phase);
      imp3=new("imp3",this);
      
    endfunction
    
   function void write(string str) ;
     `uvm_info("sub3",$sformatf("receiving sub3 :%s",str),UVM_NONE);
   endfunction
  endclass 
  
  
  
  class env extends uvm_env;
    `uvm_component_utils(env)
    producer p1;
    SUB1 s1;
    SUB2 s2;
    SUB3 s3;
    
    function new(string name="env",uvm_component parent =null);
      super.new(name,parent);
    endfunction
    function void build_phase(uvm_phase phase);
      super.build_phase(phase);
      p1=producer::type_id::create("p1",this);
      s1=SUB1::type_id::create("sub1",this);
      s2=SUB2::type_id::create("sub2",this);
      s3=SUB3::type_id::create("sub3",this);
 endfunction
     function void connect_phase(uvm_phase phase);
      super.connect_phase(phase);
       p1.send.connect(s1.imp1);
       p1.send.connect(s2.imp2);
       p1.send.connect(s3.imp3);
     endfunction
  endclass
  
   class test extends uvm_test;
     `uvm_component_utils(test)
    env e;
     function new(string name="test",uvm_component parent =null);
      super.new(name,parent);
    endfunction
    function void build_phase(uvm_phase phase);
      super.build_phase(phase);
      e=env::type_id::create("e",this);

    endfunction
     
  endclass
  module tb;
    initial
      begin
        run_test("test");
      end
  endmodule
    
